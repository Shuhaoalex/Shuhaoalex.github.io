{"meta":{"title":"Yanksi's Blog","subtitle":"Learn the World","description":"A small personal website holding everything about me","author":"Yanksi Li","url":"https://yanksi.li","root":"/"},"pages":[{"title":"","date":"2022-07-05T05:46:46.297Z","updated":"2022-07-05T05:46:46.297Z","comments":true,"path":"404.html","permalink":"https://yanksi.li/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":true,"path":"about/index.html","permalink":"https://yanksi.li/about/index.html","excerpt":"","text":"Hobbies Cooking Video Gaming Steam Badminton Photography (Entry Level) 版权声明：博客内的所有原创内容（包括但不限于文章、图像等）除特别声明外均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议，任何人都可以自由传播，但不得用于商用且必须署名并以相同方式分享。"},{"title":"All Categories","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":true,"path":"categories/index.html","permalink":"https://yanksi.li/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":true,"path":"comments/index.html","permalink":"https://yanksi.li/comments/index.html","excerpt":"","text":"Comment AreaPleace comment below with the thing you want to tell me."},{"title":"","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":true,"path":"gallery/index.html","permalink":"https://yanksi.li/gallery/index.html","excerpt":"","text":"随手拍记录生活本网站启用了lazyload，如果图片加载不出来可以停在这个位置稍微等一下，不停刷来刷去可能导致图片得更加缓慢。。。 一些记不清楚什么时候拍的照片。。。 2021.4.22 Scarborough 2021.5.1 Lake Ontario 2021.5.5 Neiboroughood 2021.9.10 BlueMountain"},{"title":"","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":true,"path":"mylist/index.html","permalink":"https://yanksi.li/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":false,"path":"shuoshuo/index.html","permalink":"https://yanksi.li/shuoshuo/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-07-05T05:46:46.409Z","updated":"2022-07-05T05:46:46.409Z","comments":true,"path":"tags/index.html","permalink":"https://yanksi.li/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Reinforcement Learning I","slug":"Reinforcement-Learning-I","date":"2022-06-28T06:11:20.000Z","updated":"2022-07-05T05:46:46.401Z","comments":true,"path":"2022/06/28/Reinforcement-Learning-I/","link":"","permalink":"https://yanksi.li/2022/06/28/Reinforcement-Learning-I/","excerpt":"","text":"Value functionsA policy is used to define the law of actions we need to follow when interacting with the environment, and a corresponding state-value function is defined as the expected reward that we can get in the future after we get to a state. Similarly, the action-value function can be defined as A recursive definition of the state-value function can be derived as following This recursive definition is called the Bellman equation for . Optimal Policies and Optimal Value FunctionsA policy is defined to be better than or euqal to a policy if its expected return is greater than or equal to that of for all states. In other words, iff for all . An optimal policy can be defined as the policy that is not worse than any other policies. The state-value function corresponding to the optimal policy can be defined as Optimal action-value function can be defined as The relationship between and can be Dynamic ProgrammingPolicy EvaluationThe policy evaluation is defined as the process to compute the corresponding state-value function for an arbitrary policy . would satisfy the Bellman equation for policy . If the dynamics of the environment is completely known, this can be easily computed by solving a large linear system according to the definition formula for . However, using a iterative way to solve for such system would be preferred as the solution itself would be a fixed point in such linear system. The initial approximation can be chosen arbitrarily (except for those termianl states, if any, must be 0). Policy Evaluation in Python:# V here should be a class representing the value function to be optimized with # __getitem__ and __setitem__ implemented. While V[terminal] should always return 0 # S should be the collection of all possible states that can appear in the # environment # PI should be a callable that returns the actions available for a state and the # their respective possabilities of happening under the current policy # T should be a callable representing the transition function of the environment, # this callable should takes in a state and the action chosen, returns all the # possible subsequent states, the possible rewards of the action taken and the # possibility of the state-reward pair. def policy_eval(V, S, PI, T, theta, gamma): while True: delta = 0 for s in S: v = V[s] temp = 0 for a, pa in PI(s): for (s_p, r), psr in T(s, a): temp += pa * psr * (r + gamma * V[s_p]) V[s] = temp delta = max(delta, abs(v - temp)) if delta &lt; theta: break Policy ImprovementGiven the original policy and the evaluated value function of it, it is easy to prove that we can get a better or equally good policy if we have: for an state , and for all . By induction, we can show that the policy entirely defined by the greedy formula shown above would be the optimal policy we have under the current value function.","categories":[{"name":"Study Notes","slug":"Study-Notes","permalink":"https://yanksi.li/categories/Study-Notes/"},{"name":"Machine Learning","slug":"Study-Notes/Machine-Learning","permalink":"https://yanksi.li/categories/Study-Notes/Machine-Learning/"},{"name":"English","slug":"English","permalink":"https://yanksi.li/categories/English/"},{"name":"Reinforcement Learning","slug":"Study-Notes/Machine-Learning/Reinforcement-Learning","permalink":"https://yanksi.li/categories/Study-Notes/Machine-Learning/Reinforcement-Learning/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://yanksi.li/tags/Reinforcement-Learning/"}]},{"title":"Study Notes For Fractional Calculus II","slug":"Study-Notes-For-Fractional-Calculus-II","date":"2021-05-18T04:43:40.000Z","updated":"2022-07-05T05:46:46.401Z","comments":true,"path":"2021/05/18/Study-Notes-For-Fractional-Calculus-II/","link":"","permalink":"https://yanksi.li/2021/05/18/Study-Notes-For-Fractional-Calculus-II/","excerpt":"","text":"Differintegrals for FunctionsProof of Differintegral Power RuleLet .Then by standard calculus, we can have the following relationships,By extending the order of the integral to a real number, we can have the following:We can see that the derivative formula we derived here using integration formula matches the fractional derivative formula presented at the very begining of {% post_link Study-Notes-For-Fractional-Calculus-I ‘Note I’ %}. Now we want to give a formal proof that the intuitive “fractional derivative power rule” we get in the previous note is actually true by using R-L Integral. Want to show: Proof:Therefore, At this step, we can see that the fractional power rule we derived from our intuitive guess do matches with our theory. Differintegrals for Exponential Functions Differintegrals for Sine and CosineAnd intuitive way for deriving differintegral for sine function can be taking the taylor expansion of the sine function and apply differintegral power rule to each term in the formula. As our differintegral power rule has base point 0, the formula for sine can be derived as following:Do a few examples using the formula derived above:Ex1:Ex2:Ex3:We can see that deriving formula for sine function using taylor exapansion will make the result function no longer periodic, which is an undesired behavior. Therefore, we want to derive the formula in another way.In standard calculus, we have the following relationships:We now want to show if the formula we derived from intuition is actually the case. To do that, we need to findout a proper value for the base point . In the course, the is simply done by taking multiple values of and compare the graph of the formula derived by RL fractional integration and the graph of the guessed formula. Turns out the when , two graph gradually matches each other. Short SummaryFor now, we have derived differintegrals for the following functions: For the fractional power rule, we do not have the same good property, having as base point, as others. The reason for this to be the case is that polynomials are not bounded in range for some . Therefore, the integration term inside the RL integral formula is not going to converge. Stickers by the end of this note Using numerical trick for showing the validity of the differintegral formula for trignometry is evil, need to derive concrete a more concrete proof. Differintegrals over sine and cosine are basically shifting the phase of the function, this seems to be a really good property and we might be able to use this property to quickly derive the differintegral of any function using Fourier Transform.","categories":[{"name":"Study Notes","slug":"Study-Notes","permalink":"https://yanksi.li/categories/Study-Notes/"},{"name":"English","slug":"English","permalink":"https://yanksi.li/categories/English/"},{"name":"Math","slug":"Study-Notes/Math","permalink":"https://yanksi.li/categories/Study-Notes/Math/"},{"name":"Fractional Calculus","slug":"Study-Notes/Math/Fractional-Calculus","permalink":"https://yanksi.li/categories/Study-Notes/Math/Fractional-Calculus/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://yanksi.li/tags/Math/"},{"name":"Fractional Calculus","slug":"Fractional-Calculus","permalink":"https://yanksi.li/tags/Fractional-Calculus/"}]},{"title":"Study Notes For Fractional Calculus I","slug":"Study-Notes-For-Fractional-Calculus-I","date":"2021-05-16T23:38:29.000Z","updated":"2022-07-05T05:46:46.401Z","comments":true,"path":"2021/05/16/Study-Notes-For-Fractional-Calculus-I/","link":"","permalink":"https://yanksi.li/2021/05/16/Study-Notes-For-Fractional-Calculus-I/","excerpt":"","text":"Fractional derivative for polynomialIn most cases, when we are calculating different orders of derivatives of a function, the orders of the derivatives we are facing are non negative integer values. For example, for function , we have:From formulas above, we can easily acquire the general formula for the -th derivative of .Recall that where . Therefore, we can use Gamma function to generalize the domain of from to .Then,Ex1: Ex2: Ex3: {% note warning, In the result of _Ex3_， we can see that the result function is not continuous over point ， while the 0th and first order derivative of the original function is actually continuous over the point. This should due to a definition problem (not sure about whether this problem can be fixable in the further definition of fractional calculus). %} Deriving general formula for fractional derivativeThe Grünwald-Letnikov Fractional DerivativeRecall the very first definition of “derivative”:Note: Using backward difference here for simplicity in the further steps.Then,Goal here is to make . Therefore,Define for some constant , as , if . Then,At this stage, we have defined the formula for the GL derivative: The Riemann-Liouville Fractional IntegralIn order to get even more compact formula, we want to define a new concept called negative binomial coefficients. Recall the formula for the normal negative binomial coefficients:Numerator in the formula has terms in total. Therefore, by replacing with in the formula, we can have: Therefore, Consider : Consider : Similarly: As integral can be considered as “inversed derivative”, here we can define a new notation called Riemann-Liouville Fractional Integral: Ex: for Properties of The Riemann-Liouville Fractional Integral Proof for the third property: Stickers by the end of this note The conversion from GL fractional derivative to RL fraction integral still seems to be unclear to me, need further investigation about the topic. The formula for RL fraction integral seems to be too good to be true, as it can compute high order integration with only one integration. And the term inside the formula seems to have some underlying connection to taylor expansion. Work out the proof for the missing step in the course.","categories":[{"name":"Study Notes","slug":"Study-Notes","permalink":"https://yanksi.li/categories/Study-Notes/"},{"name":"English","slug":"English","permalink":"https://yanksi.li/categories/English/"},{"name":"Math","slug":"Study-Notes/Math","permalink":"https://yanksi.li/categories/Study-Notes/Math/"},{"name":"Fractional Calculus","slug":"Study-Notes/Math/Fractional-Calculus","permalink":"https://yanksi.li/categories/Study-Notes/Math/Fractional-Calculus/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://yanksi.li/tags/Math/"},{"name":"Fractional Calculus","slug":"Fractional-Calculus","permalink":"https://yanksi.li/tags/Fractional-Calculus/"}]},{"title":"Fast Inverse Square Root Algorithm Explained","slug":"Fast-Inverse-Square-Root-Algorithm-Explained","date":"2021-05-02T19:18:10.000Z","updated":"2022-07-05T05:46:46.297Z","comments":true,"path":"2021/05/02/Fast-Inverse-Square-Root-Algorithm-Explained/","link":"","permalink":"https://yanksi.li/2021/05/02/Fast-Inverse-Square-Root-Algorithm-Explained/","excerpt":"","text":"Why we need a fast inverse square root algorithmThe inverse square root means for . In the field of Computer Graphics, the inverse square root of a number is usually used for normalizing vectors. As this operator is used a lot, deriving a fast algorithm for it becomes very important. Algorithm itselffloat Q_rsqrt(float number) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = *( long * ) &amp;y; // evil floating point bit hack i = 0x5f3759df - (i &gt;&gt; 1); // what the fuck? y = * (float * ) &amp;i; y = y * ( threehalfs - (x2 * y * y) ); // 1st iteration // y = y * ( threehalfs - (x2 * y * y) ); // 2nd iteration, can be removed return y; } Intuitions behind this algorithmUse multiply instead of division in codeIn general, computing the division between two numbers are much more costly than multiplying two numbers together in computer. This can be easily verified by running the following C program. CodeOutput#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; const int sz = 1 &lt;&lt; 20; const int trail = 100; int main() { clock_t start, end; float * arr1 = (float*)malloc(sizeof(float) * sz); float * arr2 = (float*)malloc(sizeof(float) * sz); float * arr3 = (float*)malloc(sizeof(float) * sz); /* In order to avoid the timing inconsistency caused by 'cold cache', we need to access every single elements inside the arrays we use for performance profiling. */ for (int i = 0; i &lt; sz; ++i) { arr1[i] = (float)rand() / (float)RAND_MAX; arr2[i] = (float)rand() / (float)RAND_MAX; arr3[i] = 0; } double time_used_multiply = 0; double time_used_division = 0; /* To avoid our code any unnecessary optimization provided by compiler, we do multiplication job and division job alternativly in each profiling loop. */ for (int t = 0; t &lt; trail; ++t) { start = clock(); for (int i = 0; i &lt; sz; ++i) { arr3[i] = arr1[i] * arr2[i]; } end = clock(); time_used_multiply += ((double) (end - start)) / CLOCKS_PER_SEC; start = clock(); for (int i = 0; i &lt; sz; ++i) { arr1[i] = arr3[i] / arr2[i]; } end = clock(); time_used_division += ((double) (end - start)) / CLOCKS_PER_SEC; } time_used_multiply /= trail; printf(\"Average time used for multiplication job: %f\\n\", time_used_multiply); time_used_division /= trail; printf(\"Average time used for division job: %f\\n\", time_used_division); } Average time used for multiplication job: 0.001960 Average time used for division job: 0.005490 As division is much more costly than computing multiplication, we want to minimize the number of occurance of division operators. Try not to use the sqrt() functionThe cost of sqrt() can be estimated using the following C program. CodeOutput#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; const int sz = 1 &lt;&lt; 20; const int trail = 100; int main() { clock_t start, end; float * arr1 = (float*)malloc(sizeof(float) * sz); float * arr2 = (float*)malloc(sizeof(float) * sz); for (int i = 0; i &lt; sz; ++i) { arr1[i] = (float)rand() / (float)RAND_MAX * 1024; arr2[i] = 0; } double time_used = 0; for (int t = 0; t &lt; trail; ++t) { start = clock(); for (int i = 0; i &lt; sz; ++i) { arr2[i] = sqrt(arr1[i]); } end = clock(); time_used += ((double) (end - start)) / CLOCKS_PER_SEC; } time_used /= trail; printf(\"Average time used for sqrt job: %f\\n\", time_used); } Average time used for sqrt job: 0.004730 Algorithm explainedNewton’s MethodNewton’s method can be used to find a root of a function in an iterative manner. Therefore, we can convert the problem of computing to a root-finding problem that is solvable by using Newton’s method in the following way. We want to find a such that . Therefore, . Then is a function that has a root when . Using Newton’s method to derive the iterative routine for the problem: In order to achieve desired accuracy with minimum number of iterations needed, we want our initial guess of to be as close to the true value of as possible. Floating point numberAccording to IEEE 754, floating point number is represented by 32 bits in the following manner. For detailed description about this representation, can take a look at this. In general, the first bit represent the sign of the number, 0 for positive while 1 for negative. The unsigned number represented by the following 8 bits is used to represent the exponent of the floating number, the actually value for the exponent is . The remaining 23 bits are used to represent the mantissa of the floating point number, as scientific representation requires the first digit of the number to be non-zero, the value for the first digit of mantissa in the binary representation can only be 1. Therefore, we can save this digit for higher accuracy representation. In the end, the value of the number behind the scene is: Dark MagicTake the logarithm of the number, we will get: As must be a number between 0 and 1, we can go find an approximation of for between 0 and 1. A good approximation for the function would be the following function: , where (Value from the video, and I did not verify the number by myself). Apply the approximation to the formula above: Notice here, we have in our formula, which is exactly the bit representation of the floating point number! We also have the following relationship: . Let be the our close approximation to . Therefore: Therefore, the WTF line in the code seems to be clear at this stage. The -(i&gt;&gt;1) term is calculating , while the number 0x5f3759df in front of this term should be the value of . However, I found that there seems to be a little inconsistency between the value of hiding behind that mysterious long and the value of presented above. The behind the long can be calculted using the following program. CodeOutput#include &lt;stdio.h&gt; int main() { long target = 0x5f3759df; long a = 3 * (1 &lt;&lt; 22) * 127; long b = 3 * (1 &lt;&lt; 22) * 0.0430; double mu = (double)(a - target) / (3 * (1 &lt;&lt; 22)); printf(\"%e\\n\", mu); printf(\"%08lx\\n\", a - b); printf(\"%08lx\\n\", target); } 4.504657e-002 5f37be77 5f3759df We can see that the value of behind the scene is actually around . I prefer to think that this is a small mistake made by the video editor when presenting the value of . Assemble everything togetherAfter all these efforts, we finally get the binary representation of the number approximate value of . And refine our approximation by using Newton’s Method for one or two iterations. Error Estimation and Performance ProfilingThe error of the algorithm is estimated over the entire domain of float using log-space grid. Here is the code and output of this profiling process. C codeC code outputPython codeError plot#include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;float.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; void logspace(float start, float end, int n, float* u) { float pow_start = log2f(start); float pow_end = log2f(end); float step = (pow_end - pow_start) / (n - 1); for (int i = 0; i &lt; n; ++i) { u[i] = powf(2, pow_start + i * step); } } static inline float Q_rsqrt(float y) { long i; float x2; x2 = y * 0.5F; i = 0x5f3759df - ((*( long * ) &amp;y) &gt;&gt; 1); // what the fuck? y = * (float * ) &amp;i; y *= ( 1.5F - (x2 * y * y) ); // 1st iteration // y *= ( 1.5F - (x2 * y * y) ); // 2nd iteration, can be removed return y; } int main() { int profiling = 1; int trail = 100; int sz = 1 &lt;&lt; 20; float * xs = (float*)malloc(sizeof(float) * sz); logspace(FLT_MIN, FLT_MAX, sz, xs); float * result = (float*)malloc(sizeof(float) * sz); float * ground = (float*)malloc(sizeof(float) * sz); for (int i = 0; i &lt; sz; ++i) { result[i] = Q_rsqrt(xs[i]); } for (int i = 0; i &lt; sz; ++i) { ground[i] = 1 / sqrt(xs[i]); } if (profiling) { double quick_alg_time = 0; double orig_alg_time = 0; clock_t start, end; for (int t = 0; t &lt; trail; ++t) { for (int i = 0; i &lt; sz; ++i) { result[i] = 0; } for (int i = 0; i &lt; sz; ++i) { ground[i] = 0; } start = clock(); for (int i = 0; i &lt; sz; ++i) { result[i] = Q_rsqrt(xs[i]); } end = clock(); quick_alg_time += ((double) (end - start)) / CLOCKS_PER_SEC; start = clock(); for (int i = 0; i &lt; sz; ++i) { ground[i] = 1 / sqrt(xs[i]); } end = clock(); orig_alg_time += ((double) (end - start)) / CLOCKS_PER_SEC; } quick_alg_time /= trail; printf(\"Average time used for quick algorithm: %f\\n\", quick_alg_time); orig_alg_time /= trail; printf(\"Average time used for naive approach: %f\\n\", orig_alg_time); } FILE* output_f = fopen(\"output.bin\", \"wb\"); if (fwrite(xs, sizeof(float), sz, output_f) != sz) { perror(\"Cannot write to file!\"); return 1; } if (fwrite(result, sizeof(float), sz, output_f) != sz) { perror(\"Cannot write to file!\"); return 1; } if (fwrite(ground, sizeof(float), sz, output_f) != sz) { perror(\"Cannot write to file!\"); return 1; } } Average time used for quick algorithm: 0.004890 Average time used for naive approach: 0.005990 import struct import numpy as np import matplotlib.pyplot as plt sz = 1 &lt;&lt; 20 with open(\"./output.bin\", \"rb\") as f: form = \"f\" * sz xs = np.array(struct.unpack(form, f.read(struct.calcsize(form)))) results = np.array(struct.unpack(form, f.read(struct.calcsize(form)))) grounds = np.array(struct.unpack(form, f.read(struct.calcsize(form)))) plt.loglog(xs, np.abs(grounds - results), base=2) plt.show() From the output we can see that even with my naive implementation of the quick inverse square root algorithm, the algorithm still out performs the naive approach. The error of the algorithm is acceptable for with reasonable scale. As the algorithm can be widely used in the field of computer graphics, keeping the scale of the scene reasonable should be a prerequisite for using the algorithm. Reference Youtube Video “Fast Inverse Square Root — A Quake III Algorithm” https://www.youtube.com/watch?v=p8u_k2LIZyo","categories":[{"name":"Study Notes","slug":"Study-Notes","permalink":"https://yanksi.li/categories/Study-Notes/"},{"name":"Numerical Analysis","slug":"Study-Notes/Numerical-Analysis","permalink":"https://yanksi.li/categories/Study-Notes/Numerical-Analysis/"},{"name":"English","slug":"English","permalink":"https://yanksi.li/categories/English/"},{"name":"HPC","slug":"Study-Notes/HPC","permalink":"https://yanksi.li/categories/Study-Notes/HPC/"},{"name":"Computer Graphics","slug":"Study-Notes/Computer-Graphics","permalink":"https://yanksi.li/categories/Study-Notes/Computer-Graphics/"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://yanksi.li/tags/Computer-Graphics/"},{"name":"Error Analysis","slug":"Error-Analysis","permalink":"https://yanksi.li/tags/Error-Analysis/"},{"name":"High Performance Computing","slug":"High-Performance-Computing","permalink":"https://yanksi.li/tags/High-Performance-Computing/"}]},{"title":"A Short Proof Showing Why (1-x)(1+x) Is Different From (1-x^2) During Computation","slug":"A-Short-Proof-Showing-Why-1-x-1-x-Is-Different-From-1-x-2-During-Computation","date":"2021-04-20T00:26:38.000Z","updated":"2022-07-05T05:46:46.297Z","comments":true,"path":"2021/04/20/A-Short-Proof-Showing-Why-1-x-1-x-Is-Different-From-1-x-2-During-Computation/","link":"","permalink":"https://yanksi.li/2021/04/20/A-Short-Proof-Showing-Why-1-x-1-x-Is-Different-From-1-x-2-During-Computation/","excerpt":"","text":"When computing , we know that catastrophic cancellation may happen when we are computing the minus operation between and when we have close to 1. While this kind of cancellation may not happen when we are computing under the same condition, as close to one does not implies that should also be extremely close to . I am going to show how can we construct so that catastrophic cancellation will only happen in while not in . Assume is a small number, let . Then, will be evaluated in the following form:For , we know that the only place that rounding error can happen on should be term . There should be no cancellation happening on the part, as it is going to be impossible for us to represent by otherwise. In this case, in order to maximize the rounding error during the computation of , we want to be as large as possible while making (i.e. Let term gets rounded off completely).Therefore,Therefore, the maximum value can take should be less than . Catastrophic cancellation should happen when computing when we have right below the theoretical bound we just derived. However, the same kind of cancellation will not happen when we are computing . As the value of is much larger than , there’s no reason for us to suffer from the cancellation problem in this case.Because the value of will be much smaller than that of , we can treat the upper bound of as during experiment.The MATLAB code and its corresponding output for the experiment I have done as provided below. The value of during experiment was set to . codeoutputdelta = sqrt(1.9 * eps); x = 1 + delta; a = (1 - x^2); b = (1 - x) * (1 + x); disp((a - b)/b); &gt;&gt; experiment 5.4052e-10 We can see that the error level here is pretty high comparing to the value of . Thus, the two expressions are indeed different from each other during evalution.","categories":[{"name":"Study Notes","slug":"Study-Notes","permalink":"https://yanksi.li/categories/Study-Notes/"},{"name":"Numerical Analysis","slug":"Study-Notes/Numerical-Analysis","permalink":"https://yanksi.li/categories/Study-Notes/Numerical-Analysis/"},{"name":"English","slug":"English","permalink":"https://yanksi.li/categories/English/"}],"tags":[{"name":"Error Analysis","slug":"Error-Analysis","permalink":"https://yanksi.li/tags/Error-Analysis/"}]},{"title":"从0.5开始搭建属于自己的博客网站","slug":"从0-5开始搭建属于自己的博客网站","date":"2021-04-17T17:42:50.000Z","updated":"2022-07-05T05:46:46.401Z","comments":true,"path":"2021/04/17/从0-5开始搭建属于自己的博客网站/","link":"","permalink":"https://yanksi.li/2021/04/17/%E4%BB%8E0-5%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"","text":"折腾了三天，终于算是搞定了这个现在看起来还可以的小窝，记录下整个折腾过程。 模板选择博客的模板我最终采用的是一个叫Volantis的Hexo主题。得益于其高度模块化的设计，使用它搭建个人页面就和搭积木一样简单。鉴于我的整个搭积木过程使用的基本都是前人的工作，再用 “从0开始搭建” 这种比较常见的标题未免会闲得过于自大，因此在这里改成 “从0.5开始搭建”。 开始前的准备工作需要提前安装的应用Node.js npm Git Hexo Volantis 不出意外的话npm会在安装的Node.js的同时被自动安装，不用特别再去下载安装。 需要拥有的知识 知道Markdown的基本语法 知道git的基本操作 知道如何高效地搜索和解决问题，配置阶段绝大多数的问题都可以通过搜索和阅读文档解决 开始配置鉴于Volantis的官方文档十分详尽，在这里我就不对整个主题的配置过程进行赘述，主要会描述如何构建个人网页的整体框架。 部署方式我选择的方案是利用Github Action自动生成网页，然后使用Vercel进行部署和网页托管，我认为这样做的好处有以下两点。 使用Vercel托管网站貌似能够在国内获得更快一点的访问速度，并且Vercel的网站管理功能相对于Github Page会更全面一些。 对博客进行自动部署，每次部署时甚至连hexo d都不用敲，懒人福音。 分离博客的网页部分与代码部分。将这两个部分分别存在两个repository中可以方便之后将博客部署到别的地方（虽然不知道有什么用）。这条其实主要是为了满足我的精神洁癖，虽然部署也可以通过branch实现，但我嫌弃这种方法会弄脏我的repository。 具体步骤 在Github新建两个repository，一个用来存放博客代码，另一个作为部署时的工具人 跟随这篇教程来配置自动化的部署这里需要注意一下的是如果你的Volantis主题文件夹是通过git submodule添加到博客代码repo中的，需要对知乎回答原文中的.github/workflows/deploy.yml文件稍作修改，修改后的文件如下 代码原因name: Hexo Deploy on: push: branches: - master jobs: build: runs-on: ubuntu-18.04 if: github.event.repository.owner.id == github.event.sender.id steps: - name: Checkout source uses: actions/checkout@v2 with: ref: master submodules: &#39;recursive&#39; - name: Setup Node.js uses: actions/setup-node@v1 with: node-version: &#39;12&#39; - name: Setup Hexo env: ACTION_DEPLOY_KEY: $ run: | mkdir -p ~/.ssh/ echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa chmod 700 ~/.ssh chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.email &quot;Your Email Here&quot; git config --global user.name &quot;Your Name Here&quot; npm install hexo-cli -g npm install - name: Deploy run: | hexo clean hexo deploy actions/checkout@v2不再默认支持检出submodule，需要手动将submodule这个field设置为recursive。 跟随Vercel的傻瓜式引导完成将网页从工具人repo部署到Vercel的操作。在这步结束后可以在Vercel里边设置一下网页的新名字，或者可以去买一个域名然后来Vercel设置一下。Vercel域名卖的都比较贵，比较之下我感觉从Google Domains买域名比较便宜一些 简单的三步走完成后，你现在将最新的博客内容push到博客仓库的时候，整套自动部署流程会被启动，Vercel完成部署后还会给你发邮件。 配置过程中的小坑LeanCloud对于海外党来说，注册LeanCloud时登记手机号的流程会比较迷惑。填写手机号时LeanCloud没有提供国家码的下拉菜单，所以写电话的时候我们需要自己添加国家码（以美国例：+1··········）。 Artitalk在你的说说页面停用pjax！！！在你的说说页面停用pjax！！！在你的说说页面停用pjax！！！（重要的事情说三遍，因为这个问题我浪费了两个多小时。。。。） Gallery如果你想在博客里弄画廊页面的话，建议现将一个页面上传到图床上再以链接的形式引用，我用的是去不图床。不知道是什么原因，我将图片放在repo里再引用的时候经常出现有些图片加载不出来的情况。上传图片到图床时建议将图片压缩一下再上传，这样做可以提升网页中图片的加载速度。我用的是这个网站做图片压缩，感觉压缩后图片的质量并没有损失很多。 icon vs. avatar vs. imgicon用的是Font Awesome里边图标的class，直接把值复制过来就行。avatar和img的区别我其实搞得也没有非常明白，不过根据官方document，两种field的值都是应该一个图片的链接，唯一的区别在于如果将图片链接填在avatar里边图片的边缘会被裁切成圆形，填在img里边图片的边缘会呈方形。 想做的事 为Volantis主题添加一个简单的多语言界面接口，令网页的文字可以随当前语言环境变化","categories":[{"name":"生活","slug":"生活","permalink":"https://yanksi.li/categories/%E7%94%9F%E6%B4%BB/"},{"name":"折腾","slug":"生活/折腾","permalink":"https://yanksi.li/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"},{"name":"中文","slug":"中文","permalink":"https://yanksi.li/categories/%E4%B8%AD%E6%96%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yanksi.li/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://yanksi.li/tags/Volantis/"}]}],"categories":[{"name":"Study Notes","slug":"Study-Notes","permalink":"https://yanksi.li/categories/Study-Notes/"},{"name":"Machine Learning","slug":"Study-Notes/Machine-Learning","permalink":"https://yanksi.li/categories/Study-Notes/Machine-Learning/"},{"name":"English","slug":"English","permalink":"https://yanksi.li/categories/English/"},{"name":"Reinforcement Learning","slug":"Study-Notes/Machine-Learning/Reinforcement-Learning","permalink":"https://yanksi.li/categories/Study-Notes/Machine-Learning/Reinforcement-Learning/"},{"name":"Math","slug":"Study-Notes/Math","permalink":"https://yanksi.li/categories/Study-Notes/Math/"},{"name":"Fractional Calculus","slug":"Study-Notes/Math/Fractional-Calculus","permalink":"https://yanksi.li/categories/Study-Notes/Math/Fractional-Calculus/"},{"name":"Numerical Analysis","slug":"Study-Notes/Numerical-Analysis","permalink":"https://yanksi.li/categories/Study-Notes/Numerical-Analysis/"},{"name":"HPC","slug":"Study-Notes/HPC","permalink":"https://yanksi.li/categories/Study-Notes/HPC/"},{"name":"Computer Graphics","slug":"Study-Notes/Computer-Graphics","permalink":"https://yanksi.li/categories/Study-Notes/Computer-Graphics/"},{"name":"生活","slug":"生活","permalink":"https://yanksi.li/categories/%E7%94%9F%E6%B4%BB/"},{"name":"折腾","slug":"生活/折腾","permalink":"https://yanksi.li/categories/%E7%94%9F%E6%B4%BB/%E6%8A%98%E8%85%BE/"},{"name":"中文","slug":"中文","permalink":"https://yanksi.li/categories/%E4%B8%AD%E6%96%87/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://yanksi.li/tags/Reinforcement-Learning/"},{"name":"Math","slug":"Math","permalink":"https://yanksi.li/tags/Math/"},{"name":"Fractional Calculus","slug":"Fractional-Calculus","permalink":"https://yanksi.li/tags/Fractional-Calculus/"},{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"https://yanksi.li/tags/Computer-Graphics/"},{"name":"Error Analysis","slug":"Error-Analysis","permalink":"https://yanksi.li/tags/Error-Analysis/"},{"name":"High Performance Computing","slug":"High-Performance-Computing","permalink":"https://yanksi.li/tags/High-Performance-Computing/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yanksi.li/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://yanksi.li/tags/Volantis/"}]}